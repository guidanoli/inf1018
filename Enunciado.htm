<html><head>
<title>Software Básico - Primeiro Trabalho</title>

<link media="screen,projection,handheld" href="http://www.inf.puc-rio.br/~inf1018/style.css", type="text/css" rel="stylesheet">
<style>
.wrap {
   margin: 3em;
}
body {
   background: white;
}
</style>
</head>
<body>
<div class="wrap">
<h1>INF1018 - Software Básico (2018.2)<br>
Primeiro Trabalho</h1>

<h2>Armazenando Estruturas de Inteiros</h2>
<p>
O objetivo do trabalho é implementar, na linguagem C, uma função
(<b><code>grava_structs</code></b>)
que armazena um array de structs em um 
arquivo binário de forma compacta (isto é, sem <em>paddings</em>)
e uma função (<b><code>dump_structs</code></b>) que permite visualizar 
um arquivo gerado por <b><code>grava_structs</code></b>.
<br><br>
<h3>Instruções Gerais</h3>
<hr>
<ul>
<li>Leia com atenção o enunciado do trabalho e as instruções para a entrega.
<font color="blue">Em caso de dúvidas, não invente. Pergunte!</font>
<li>O trabalho deve ser entregue até 
<font color="blue"> o final do dia 12/10 (23:59)</font>.
<li>Trabalhos entregues após o prazo perderão um ponto por dia de atraso.
<li>Trabalhos que não compilem (i.e., que não produzam um executável) 
não serão considerados, ou seja, receberão grau zero.
<li>Os trabalhos podem ser feitos em grupos de <b>no máximo</b> dois alunos.
</li>
<li>Alguns grupos poderão ser chamados para apresentar seus trabalhos.
</li>
</ul>

<hr>
<h3>Função <code>grava_structs</code></h3>
<small>
<pre>int grava_structs (int nstructs, void *valores, char *campos, char ord, char *arquivo); 
</pre></small>

A função <b><code>grava_structs</code></b> recebe: 
<ul>
<li> <code>nstructs</code>: o número de elementos do array de structs 
a ser escrito em arquivo 
</li><li> <code>valores</code>: endereço do array de structs propriamente dito
</li><li> <code>campos</code>: descrição dos campos das structs que compõem o array
</li><li> <code>ord</code>: 
um caractere que indica se os valores inteiros contidos nas estruturas devem ser armazenados no arquivo em ordenação <em>little endian </em>('L')ou <em>big endian</em> ('B')
</li><li> <code>arquivo</code>: o nome do arquivo a ser criado
</li></ul>

A função deverá retornar 0 em caso de sucesso, e -1 em caso de erro.
Apenas erros de E/S (erro na abertura ou gravação do arquivo) devem ser considerados. Assuma que todos os argumentos fornecidos à função estão corretos.

<p>
A string <b><code>campos</code></b> representa, na ordem dada, o tipo de cada campo 
das structs, conforme abaixo:
<small><pre>
    'c' - char
    's' - short int
    'i' - int 
    'l' - long int
</pre></small>

<p>
Por exemplo, dada a declaração:
<small><pre>
struct s {
    int i1;
    long l1;
    short s1;
    char c1;
    short s2;
  };
struct s exemplo[10];
</pre></small>
a string <code>campos</code> correspondente é <b><code>"ilscs"</code></b>.
<p>
Assumindo que o nome do arquivo de saída é <b>saida1</b>,
a chamada para a gravação do array de estruturas <code><b>exemplo</b></code> com ordenaçao 
<em>little-endian</em> seria:
<small><pre>
    res = grava_structs(10, exemplo, "ilscs", 'L', "saida1");
</pre></small>
<hr>
<b>Atenção!</b>  Para acessar os valores dos campos das estruturas (armazenados na memória), 
a função deve levar em consideração as regras de alinhamento especificadas para o ambiente onde 
ela será executada (SO Linux, em uma máquina de 64 bits). 
<hr>
<h3>Formato do arquivo gerado</h3>
Os primeiros bytes do arquivo formam o cabeçalho, com informações sobre os dados 
armazenados. A seguir vem uma sequência de bytes contendo os dados propriamente
ditos.
<p> O formato do arquivo de saída deve ser o seguinte:
</p><ul>
<li>o primeiro byte do cabeçalho indica o número de structs armazenadas no arquivo,
como um <code>unsigned char</code>. Note que, portanto, o número máximo de structs armazenadas do arquivo é 255.
</li><li>o bit mais significativo do segundo byte indica se os dados estão em
<em>little_endian</em> (1) ou em <em>big_endian</em> (0).
</li><li>os próximos sete bits desse segundo byte indicam o número de campos de
cada struct armazenada. Dessa forma, o número máximo de campos é 127.
</li><li>a seguir aparecem os descritores de campos dos structs, cada um com 
dois bits.
Cada descritor é codificado da seguinte forma:
<small><pre>
    00 - char
    01 - short int
    10 - int 
    11 - long int 
</pre></small>
A porção não utilizada do último byte de cabeçalho (se houver) deve ser 
prenchida com zeros (ou seja, o inicio dos dados propriamente ditos deve estar
alinhado no próximo byte do arquivo).
</li></ul>

<p>
Após o cabeçalho são armazenados os bytes com os dados do array de structs, 
na ordenação especificada.
<font color="blue"><b>Não devem ser escritos no arquivo os bytes relativos a <em>padding</em>!</b></font>

</p><p>
Voltando ao caso do array <code>exemplo</code>, os
bytes no início do arquivo seriam:

<small><pre>
| 0000 1010 | /* há 10 structs neste arquivo */
| 1000 0101 | /* ordenação little-endian, cada struct tem 5 campos */
| 1011 0100 | /* descrição dos primeiros quatro campos (i l s c)*/
| 0100 0000 | /* descrição do último campos (s) e preenchimento com zeros */
| xxxx xxxx | /* aqui começam os dados das 10 structs */
</pre></small>

<p>
Nesse exemplo, na memória de um sistema de 64 bits executando Linux, cada struct ocuparia 
24 bytes.
Ao ser armazenada em arquivo por <code>grava_structs</code>, essa mesma
struct (sem <em>paddings</em>) ocuparia 17 bytes.

<hr>
<h3>Função <code>dump_structs</code></h3>
<small><pre>void dump_structs (char *arquivo); 
</pre></small>

<p>
A função <code>dump_structs</code> permite a visualização, na saída padrão,
de um arquivo criado por <code>grava_structs</code>.
Essa saída pode ser gerada, por exemplo, através de chamadas
a <code>printf</code>.
</p><p>
O único argumento de <code>dump_structs</code> é o nome do arquivo.
Em caso de erro na abertura ou leitura do arquivo, a função deverá emitir uma
mensagem e retornar.

</p><p>A saída da função <code>dump_structs</code> deve ser a seguinte:

</p><ul>
<li> uma linha indicando a ordenação do arquivo ("L" ou "B")
<li> uma linha indicando o número de structs armazenadas no arquivo
(em formato decimal)
<li> "dump" dos valores armazenados, em hexa, com um campo por linha. Cada
byte deve ser exibido em hexa, com dois dígitos. Deve haver um único espaço entre
cada dois bytes. 
<li> uma linha separadora no início de cada struct (caractere '*')
</ul>

Como exemplo, para o mesmo arquivo discutido acima, a saída de <code> dump_structs </code> seria

<small><pre>
L
10
*
xx xx xx xx 
xx xx xx xx xx xx xx xx
xx xx 
xx
xx xx
*
xx xx xx xx 
xx xx xx xx xx xx xx xx
xx xx 
xx
xx xx
*
xx xx xx xx 
xx xx xx xx xx xx xx xx
xx xx 
xx
xx xx
*
... (etc, até completar as 10 estruturas)
</pre></small>

onde os "xx" correspondem aos valores (em hexa) dos bytes armazenados.

<p>
</p><hr>
<h2>Implementação e Execução</h2>
<p>
Você deve criar um arquivo fonte chamado 
<font color="blue">
<b><code>grava_structs.c</code></b>
</font>
contendo as duas funções descritas acima (<code>grava_structs e dump_structs</code>)
e funções auxiliares, se for o caso.
Esse arquivo <b>não deve conter uma função <code>main</code>!</b>
<p>
O arquivo <code>grava_structs.c</code> deverá incluir o arquivo de cabeçalho
<font color="blue">
<code><b>grava_structs.h</b></code> </font>,
fornecido <a href="grava_structs.h">aqui</a>

<p>
Para testar seu programa, crie um outro arquivo,
por exemplo,
<font color="blue">
<code><b>teste.c</b></code>
</font>
, contendo a função <code>main</code>.
</p><p>
Você pode criar seu programa executável, <code>teste</code>, com a linha:
</p><pre>gcc -Wall -o teste grava_structs.c teste.c
</pre>

<br>
<hr>
<h2>Dicas</h2>
<p>Implemente seu trabalho por partes, testando cada parte implementada
antes de prosseguir.
</p><p>Por exemplo, você pode implementar primeiro a gravação do arquivo
compactado. Comece implementando casos simples (estruturas com campos
do tipo 'char'), e vá introduzindo mais tipos de campos à medida
que os casos anteriores estejam funcionando. Experimente diferentes
tipos de alinhamento (que exijam/não exijam <em>paddings</em>).
Teste as diferentes ordenações (<em>little</em> e <em>big</em>).
</p><p>
Para verificar o conteúdo do arquivo gravado, você pode usar o utilitário
<b><code>hexdump</code></b>. Por exemplo, o comando
<small></small></p><pre><small>hexdump -C &lt;nome-do-arquivo&gt;
</small></pre>
exibe o conteúdo do arquivo especificado byte a byte, em hexadecimal
(16 bytes por linha). A segunda coluna de cada linha (entre '|') exibe
os caracteres ASCII correspondentes a esses bytes, se eles existirem.
<p>Para abrir um arquivo para gravação ou leitura em formato binário,
use a função
<small></small></p><pre><small>FILE *fopen(char *path, char *mode);
</small></pre>
descrita em <code>stdio.h</code>. Seus argumentos são:
<ul>
<li> <code>path</code>: nome do arquivo a ser aberto
</li><li> <code>mode</code>: uma string que, no nosso caso, será <b>"rb"</b>
para abrir o arquivo para leitura em modo binário ou <b>"wb"</b>
para abrir o arquivo para escrita em modo binário.
</li></ul>
A letra 'b', que indica o modo binário, é ignorada em sistemas como Linux,
que tratam da mesma forma arquivos de tipos texto e binário.
Mas ela é necessária em outros sistemas, 
como Windows,
que tratam de forma diferente arquivos de tipos texto e binário
(interpretando/modificando, por exemplo, bytes de arquivos "texto"
que correspondem a caracteres de controle).
<p>Para fazer a leitura e gravação do arquivo, uma sugestão é
pesquisar as funções <code>fwrite</code>/<code>fread</code> e
<code>fputc</code>/<code>fgetc</code>.

<br><br>
</p><hr>
<h2>Entrega</h2>
<p>
Devem ser entregues <b>via Moodle</b> dois arquivos:
</p><ol>
<li> o arquivo fonte <font color="blue"><b>grava_structs.c</b></font>
<p> Coloque no início do arquivo fonte, como comentário, os nomes dos integrantes
do grupo, da seguinte forma:
</p><pre>  /* Nome_do_Aluno1 Matricula Turma */
  /* Nome_do_Aluno2 Matricula Turma */
</pre>
Lembre-se que este arquivo não deve conter a função <code>main</code>!
</li><li><p> um arquivo texto, chamado <font color="blue"><b>relatorio.txt</b></font>,
descrevendo os testes realizados,
o que está funcionando e, eventualmente, o que não está funcionando.
Mostre exemplos de estruturas testadas (casos de sucesso e insucesso,
se houver)!
Não é necessário explicar a sua implementação neste relatório. Seu programa
deve ser suficientemente claro e bem comentado.
</p><p>Coloque também no relatório o nome dos integrantes do grupo.
</p></li></ol>
<b>Coloque na área de texto da tarefa do Moodle
os nomes e turmas dos integrantes do grupo.</b>
<p>
Para grupos com alunos da mesma turma, apenas uma entrega é necessária (usando o <em>login</em> de um dos
integrantes do grupo).
<p>Se o grupo for composto por alunos de turmas diferentes, os dois alunos deverão realizar a 
entrega e avisar aos professores sobre a composição do grupo.
</div></body></html>
